# Water Sort Solver (Rust)

一个基于 Rust 编写的高性能"水瓶排序"类手游自动解题器。

## 🌟 项目简介

本项目利用深度优先搜索 (DFS) 算法，结合动态规划 (Memoization) 思想，自动寻找完成水瓶排序游戏的最短路径。它能够处理任意瓶数和高度的局面，并通过状态规范化技术极大减少了重复计算的搜索空间。

## 🚀 运行示例

### 1. 输入示例 (Input Example)

程序启动后，按行输入瓶子状态（数字代表颜色，0 代表空位，从瓶口到瓶底排列）。输入一个空行结束输入并开始计算。

<img width="916" height="2036" alt="image" src="https://github.com/user-attachments/assets/c231bbc3-c838-4776-af15-6c8ceea02bb8" />

**文本参考：**

```
请输入n行数据: 
0 0 0 0
0 0 0 0
1 2 3 4
1 2 4 3
2 5 1 3
5 3 5 1
2 5 4 4
(按回车键开始计算)
```

### 2. 返回示例 (Output Example)

**输出参考：**

```
最终答案: Some([[6, 1], [6, 0], [5, 0], [4, 1], [4, 0], [3, 4], [3, 1], [6, 3], [2, 4], [2, 1], [5, 2], [5, 0], [4, 5], [2, 4], [3, 2], [3, 4]])
(注：[1, 0] 表示将 1 号瓶顶部的颜色倒入 0 号瓶)
```

## 🛠 核心算法逻辑

### 状态规范化 (State Canonicalization)

为了处理"瓶子内容相同但位置不同"的对称局面，本项目引入了索引映射机制：

- **排序 (Sort)**：将局面中的瓶子按颜色内容进行字典序排列，生成唯一的缓存 Key。
- **映射 (Map)**：记录原始索引 ↔ 排序索引的对应关系。
- **翻译 (Translate)**：
  - 查缓存时：将缓存中的通用步骤翻译回当前局面的真实索引。
  - 存缓存时：将当前步骤翻译为通用格式存入。

## 📄 核心代码模块

- **calculate_answer**: 递归核心。处理 HashMap 缓存查询、状态排序及路径回溯。
- **get_possible_moves**: 动作生成器。严格遵循游戏规则（颜色一致、目标瓶有空位）。
- **move_warter**: 状态迁移。模拟倒水过程，支持一次性移动多格同色液体。
- **check_array_valid**: 鲁棒性检查。确保输入的每一行数据长度一致且合法。

## 🔧 开发调试

如果你在 Windows 下使用 VS Code 进行调试，建议：

- 安装 CodeLLDB 插件以获得更友好的 Vec 内容显示。
- 使用 println! 宏打印 index_key 以核对坐标转换逻辑。
